#include <stdio.h>
#include <stdlib.h>

/* =========================================================
   Q1. Insert an element at the end of an array
   ========================================================= */
void insertAtEnd() {
    int arr[100], n, i, element;

    printf("\nQ1: Insert at end of array\n");
    printf("Enter number of elements: ");
    scanf("%d", &n);

    for (i = 0; i < n; i++)
        scanf("%d", &arr[i]);

    printf("Enter element to insert: ");
    scanf("%d", &element);

    arr[n] = element;   // insert at end
    n++;

    for (i = 0; i < n; i++)
        printf("%d ", arr[i]);
}

/* =========================================================
   Linked List Structure (Used in Q2 & Q5)
   ========================================================= */
struct node {
    int data;
    struct node *next;
};

/* =========================================================
   Q2. Count number of nodes in singly linked list
   ========================================================= */
void countNodes() {
    struct node *head = NULL, *temp = NULL, *newnode;
    int count = 0, choice;

    printf("\n\nQ2: Count nodes in linked list\n");

    do {
        newnode = (struct node*)malloc(sizeof(struct node));
        scanf("%d", &newnode->data);
        newnode->next = NULL;

        if (head == NULL)
            head = temp = newnode;
        else {
            temp->next = newnode;
            temp = newnode;
        }

        printf("Add node? (1/0): ");
        scanf("%d", &choice);
    } while (choice == 1);

    temp = head;
    while (temp != NULL) {
        count++;
        temp = temp->next;
    }

    printf("Total nodes = %d\n", count);
}

/* =========================================================
   Q3. Stack using array (Push, Pop, Display)
   ========================================================= */
#define MAX 5
int stack[MAX], top = -1;

void push() {
    int x;
    if (top == MAX - 1)
        printf("Stack Overflow\n");
    else {
        scanf("%d", &x);
        stack[++top] = x;
    }
}

void pop() {
    if (top == -1)
        printf("Stack Underflow\n");
    else
        printf("Popped = %d\n", stack[top--]);
}

void displayStack() {
    int i;
    for (i = top; i >= 0; i--)
        printf("%d ", stack[i]);
}

/* =========================================================
   Q5. Reverse Singly Linked List (Iterative)
   ========================================================= */
void reverseLinkedList() {
    struct node *head = NULL, *temp = NULL, *newnode;
    struct node *prev = NULL, *curr, *next;
    int choice;

    printf("\n\nQ5: Reverse Linked List\n");

    do {
        newnode = (struct node*)malloc(sizeof(struct node));
        scanf("%d", &newnode->data);
        newnode->next = NULL;

        if (head == NULL)
            head = temp = newnode;
        else {
            temp->next = newnode;
            temp = newnode;
        }

        printf("Add node? (1/0): ");
        scanf("%d", &choice);
    } while (choice == 1);

    curr = head;
    while (curr != NULL) {
        next = curr->next;
        curr->next = prev;
        prev = curr;
        curr = next;
    }
    head = prev;

    temp = head;
    while (temp != NULL) {
        printf("%d ", temp->data);
        temp = temp->next;
    }
}

/* =========================================================
   Binary Tree Structure (Used in Q6 & Q7)
   ========================================================= */
struct tree {
    int data;
    struct tree *left, *right;
};

struct tree* newTreeNode(int data) {
    struct tree* t = (struct tree*)malloc(sizeof(struct tree));
    t->data = data;
    t->left = t->right = NULL;
    return t;
}

/* =========================================================
   Q6. Height of Binary Tree
   ========================================================= */
int height(struct tree* root) {
    if (root == NULL)
        return 0;

    int lh = height(root->left);
    int rh = height(root->right);

    return (lh > rh ? lh : rh) + 1;
}

/* =========================================================
   Q8. Maximum Subarray Sum (Kadaneâ€™s Algorithm)
   ========================================================= */
void maxSubarraySum() {
    int arr[100], n, i;
    int maxSum, currSum;

    printf("\n\nQ8: Maximum Subarray Sum\n");
    scanf("%d", &n);

    for (i = 0; i < n; i++)
        scanf("%d", &arr[i]);

    maxSum = currSum = arr[0];

    for (i = 1; i < n; i++) {
        if (currSum < 0)
            currSum = arr[i];
        else
            currSum += arr[i];

        if (currSum > maxSum)
            maxSum = currSum;
    }

    printf("Max Subarray Sum = %d\n", maxSum);
}

/* =========================================================
   Q9. Single Non-Duplicate Element (XOR Method)
   ========================================================= */
void singleNonDuplicate() {
    int arr[100], n, i, result = 0;

    printf("\n\nQ9: Single Non-Duplicate Element\n");
    scanf("%d", &n);

    for (i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
        result ^= arr[i];   // XOR logic
    }

    printf("Unique Element = %d\n", result);
}

/* =========================================================
   MAIN FUNCTION
   ========================================================= */
int main() {

    /* Uncomment ONE function at a time for practical */

    // insertAtEnd();
    // countNodes();
    // push(); pop(); displayStack();
    // reverseLinkedList();
    // maxSubarraySum();
    // singleNonDuplicate();

    return 0;
}
