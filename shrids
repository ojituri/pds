
==============================
1. Insert a node at the beginning (Linked List)
==============================

#include <stdio.h>
#include <stdlib.h>

// Structure for linked list node
struct Node {
    int data;
    struct Node *next;
};

// Function to insert node at beginning
struct Node* insertAtBeginning(struct Node *head, int value) {
    struct Node *newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->next = head;
    return newNode;
}

// Function to display list
void display(struct Node *head) {
    while (head != NULL) {
        printf("%d -> ", head->data);
        head = head->next;
    }
    printf("NULL\n");
}

int main() {
    struct Node *head = NULL;
    head = insertAtBeginning(head, 10);
    head = insertAtBeginning(head, 20);
    head = insertAtBeginning(head, 30);
    display(head);
    return 0;
}


==============================
2. Queue implementation using array
==============================

#include <stdio.h>
#define SIZE 5

int queue[SIZE];
int front = -1, rear = -1;

// Function to insert element
void enqueue(int x) {
    if (rear == SIZE - 1)
        printf("Queue Overflow\n");
    else {
        if (front == -1)
            front = 0;
        queue[++rear] = x;
    }
}

// Function to delete element
void dequeue() {
    if (front == -1 || front > rear)
        printf("Queue Underflow\n");
    else
        printf("Deleted element: %d\n", queue[front++]);
}

// Display queue
void display() {
    if (front == -1)
        printf("Queue is empty\n");
    else {
        for (int i = front; i <= rear; i++)
            printf("%d ", queue[i]);
        printf("\n");
    }
}

int main() {
    enqueue(10);
    enqueue(20);
    enqueue(30);
    display();
    dequeue();
    display();
    return 0;
}


==============================
3. Insert nodes in BST and search
==============================

#include <stdio.h>
#include <stdlib.h>

// Structure for BST node
struct Node {
    int data;
    struct Node *left, *right;
};

// Insert function
struct Node* insert(struct Node *root, int value) {
    if (root == NULL) {
        struct Node *node = (struct Node*)malloc(sizeof(struct Node));
        node->data = value;
        node->left = node->right = NULL;
        return node;
    }
    if (value < root->data)
        root->left = insert(root->left, value);
    else
        root->right = insert(root->right, value);
    return root;
}

// Search function
int search(struct Node *root, int key) {
    if (root == NULL)
        return 0;
    if (root->data == key)
        return 1;
    if (key < root->data)
        return search(root->left, key);
    return search(root->right, key);
}

int main() {
    struct Node *root = NULL;
    root = insert(root, 50);
    insert(root, 30);
    insert(root, 70);
    insert(root, 20);
    insert(root, 40);

    if (search(root, 40))
        printf("Element found\n");
    else
        printf("Element not found\n");

    return 0;
}


==============================
4. Check balanced parentheses using stack
==============================

#include <stdio.h>
#include <string.h>

#define SIZE 100
char stack[SIZE];
int top = -1;

// Push operation
void push(char c) {
    stack[++top] = c;
}

// Pop operation
char pop() {
    return stack[top--];
}

// Function to check balance
int isBalanced(char exp[]) {
    for (int i = 0; exp[i]; i++) {
        if (exp[i] == '(')
            push(exp[i]);
        else if (exp[i] == ')') {
            if (top == -1)
                return 0;
            pop();
        }
    }
    return top == -1;
}

int main() {
    char exp[] = "(a+b)*(c+d)";
    if (isBalanced(exp))
        printf("Balanced parentheses\n");
    else
        printf("Not balanced\n");
    return 0;
}


==============================
5. Detect cycle in undirected graph using DFS
==============================

#include <stdio.h>
#define V 5

int graph[V][V] = {
    {0,1,0,0,0},
    {1,0,1,0,0},
    {0,1,0,1,1},
    {0,0,1,0,0},
    {0,0,1,0,0}
};

int visited[V];

// DFS function
int dfs(int v, int parent) {
    visited[v] = 1;
    for (int i = 0; i < V; i++) {
        if (graph[v][i]) {
            if (!visited[i]) {
                if (dfs(i, v))
                    return 1;
            } else if (i != parent)
                return 1;
        }
    }
    return 0;
}

int main() {
    if (dfs(0, -1))
        printf("Cycle detected\n");
    else
        printf("No cycle detected\n");
    return 0;
}


==============================
6. Degree of each node (Adjacency list / matrix)
==============================

#include <stdio.h>

int main() {
    int V = 4;
    int adj[4][4] = {
        {0,1,1,0},
        {1,0,1,1},
        {1,1,0,0},
        {0,1,0,0}
    };

    for (int i = 0; i < V; i++) {
        int degree = 0;
        for (int j = 0; j < V; j++) {
            if (adj[i][j])
                degree++;
        }
        printf("Degree of node %d = %d\n", i, degree);
    }
    return 0;
}
